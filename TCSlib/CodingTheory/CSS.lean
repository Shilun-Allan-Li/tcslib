/-
CSS stabilizer codes (q-ary) in a single file.
This module reuses Codeword/Code and basic combinatorial style from CodingTheory.Basic.
-/

import Mathlib.Data.Finset.Basic
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Matrix.Basic
import Mathlib.Algebra.Module.Basic
import Mathlib.Algebra.Module.LinearMap.Basic
import Mathlib.Algebra.Module.Submodule.Basic
import Mathlib.Algebra.Module.Submodule.Map
import Mathlib.Algebra.Module.Submodule.Lattice
import Mathlib.LinearAlgebra.Span.Basic
import Mathlib.LinearAlgebra.FiniteDimensional.Basic
import Mathlib.Data.ZMod.Basic

import TCSlib.CodingTheory.Basic

open Finset

namespace CodingTheory

variable {α : Type*} [Field α] [Fintype α] [DecidableEq α]
variable {n : ℕ}

/-! 1) Core types and symplectic form -/

abbrev Vec (n : ℕ) (α : Type*) [Field α] := Codeword n α
abbrev SympVec (n : ℕ) (α : Type*) [Field α] := (Vec n α) × (Vec n α)

noncomputable def symplecticForm (u v : SympVec n α) : α :=
  Finset.sum (Finset.univ : Finset (Fin n)) (fun i => (u.1 i) * (v.2 i) - (u.2 i) * (v.1 i))

def IsIsotropic (S : Submodule α (SympVec n α)) : Prop :=
  ∀ u ∈ S, ∀ v ∈ S, symplecticForm (n:=n) u v = 0

structure Stabilizer (n : ℕ) (α : Type*) [Field α] [Fintype α] [DecidableEq α] where
  S : Submodule α (SympVec n α)
  isIso : IsIsotropic (n:=n) S

/-! 2) CSS from classical subspaces -/

noncomputable def dot (x y : Vec n α) : α :=
  Finset.sum (Finset.univ : Finset (Fin n)) (fun i => x i * y i)

def cssIsValid (Cz Cx : Submodule α (Vec n α)) : Prop :=
  ∀ x ∈ Cz, ∀ z ∈ Cx, dot (n:=n) x z = 0

-- Inject `Cz` and `Cx` into the symplectic space as X- and Z-type generators.
def cssStabilizer (Cz Cx : Submodule α (Vec n α)) : Submodule α (SympVec n α) :=
  Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz ⊔
  Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx

-- Helper: symplecticForm vanishes on same-type pairs and equals dot on mixed pairs.
lemma symplectic_inl_inl (x y : Vec n α) :
  symplecticForm (n:=n) (x, (fun _ => 0)) (y, (fun _ => 0)) = 0 := by
  classical
  simp [symplecticForm]

lemma symplectic_inr_inr (z w : Vec n α) :
  symplecticForm (n:=n) ((fun _ => 0), z) ((fun _ => 0), w) = 0 := by
  classical
  simp [symplecticForm]

lemma symplectic_inl_inr (x z : Vec n α) :
  symplecticForm (n:=n) (x, (fun _ => 0)) ((fun _ => 0), z) = dot (n:=n) x z := by
  classical
  simp [symplecticForm, dot]

lemma symplectic_inr_inl (z x : Vec n α) :
  symplecticForm (n:=n) ((fun _ => 0), z) (x, (fun _ => 0)) = - dot (n:=n) z x := by
  classical
  simp [symplecticForm, dot, sub_eq_add_neg, add_comm, add_left_comm, add_assoc, mul_comm]

-- If Cz ⟂ Cx under `dot`, then the CSS stabilizer is isotropic.
lemma css_isotropic_of_valid (Cz Cx : Submodule α (Vec n α))
  (h : cssIsValid (n:=n) Cz Cx) : IsIsotropic (n:=n) (cssStabilizer (n:=n) Cz Cx) := by
  classical
  -- We need to show that for any u, v in cssStabilizer, symplecticForm u v = 0
  -- Since cssStabilizer is generated by inl Cz and inr Cx, we can write any element as
  -- a sum of elements from these two subspaces.
  intro u hu v hv
  -- Use that cssStabilizer is the span of inl Cz and inr Cx
  have hspan : cssStabilizer (n:=n) Cz Cx =
    (Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz) ⊔
    (Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx) := rfl
  -- Write u and v as sums from the two subspaces
  have hu' : u ∈ (Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz) ⊔
              (Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx) := by rwa [← hspan]
  have hv' : v ∈ (Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz) ⊔
              (Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx) := by rwa [← hspan]
  -- Use Submodule.mem_sup to decompose u and v
  rcases Submodule.mem_sup.1 hu' with ⟨u1, hu1, u2, hu2, rfl⟩
  rcases Submodule.mem_sup.1 hv' with ⟨v1, hv1, v2, hv2, rfl⟩
  -- Now u = u1 + u2, v = v1 + v2 where u1, v1 in inl Cz and u2, v2 in inr Cx
  -- Use bilinearity: symplecticForm (u1 + u2) (v1 + v2) expands to four terms
  -- We show each term is 0
  rcases hu1 with ⟨x, hx, rfl⟩
  rcases hu2 with ⟨w, hw, rfl⟩
  rcases hv1 with ⟨y, hy, rfl⟩
  rcases hv2 with ⟨z, hz, rfl⟩
  -- Now u = inl x + inr w, v = inl y + inr z
  -- Expand symplecticForm using bilinearity (linearity in each argument)
  -- First expand in the second argument: symplecticForm u (v1 + v2) = symplecticForm u v1 + symplecticForm u v2
  have h_right : symplecticForm (n:=n) ((LinearMap.inl (Vec n α) (Vec n α)) x + (LinearMap.inr (Vec n α) (Vec n α)) w)
    ((LinearMap.inl (Vec n α) (Vec n α)) y + (LinearMap.inr (Vec n α) (Vec n α)) z) =
    symplecticForm (n:=n) ((LinearMap.inl (Vec n α) (Vec n α)) x + (LinearMap.inr (Vec n α) (Vec n α)) w) ((LinearMap.inl (Vec n α) (Vec n α)) y) +
    symplecticForm (n:=n) ((LinearMap.inl (Vec n α) (Vec n α)) x + (LinearMap.inr (Vec n α) (Vec n α)) w) ((LinearMap.inr (Vec n α) (Vec n α)) z) := by
    simp [symplecticForm]
    rw [Finset.sum_add_distrib]
    congr 1
    ext i
    ring
  rw [h_right]
  -- Now expand each term in the first argument
  have h_left1 : symplecticForm (n:=n) ((LinearMap.inl (Vec n α) (Vec n α)) x + (LinearMap.inr (Vec n α) (Vec n α)) w) ((LinearMap.inl (Vec n α) (Vec n α)) y) =
    symplecticForm (n:=n) ((LinearMap.inl (Vec n α) (Vec n α)) x) ((LinearMap.inl (Vec n α) (Vec n α)) y) +
    symplecticForm (n:=n) ((LinearMap.inr (Vec n α) (Vec n α)) w) ((LinearMap.inl (Vec n α) (Vec n α)) y) := by
    simp [symplecticForm]
    rw [Finset.sum_add_distrib]
    congr 1
    ext i
    ring
  have h_left2 : symplecticForm (n:=n) ((LinearMap.inl (Vec n α) (Vec n α)) x + (LinearMap.inr (Vec n α) (Vec n α)) w) ((LinearMap.inr (Vec n α) (Vec n α)) z) =
    symplecticForm (n:=n) ((LinearMap.inl (Vec n α) (Vec n α)) x) ((LinearMap.inr (Vec n α) (Vec n α)) z) +
    symplecticForm (n:=n) ((LinearMap.inr (Vec n α) (Vec n α)) w) ((LinearMap.inr (Vec n α) (Vec n α)) z) := by
    simp [symplecticForm]
    rw [Finset.sum_add_distrib]
    congr 1
    ext i
    ring
  rw [h_left1, h_left2]
  -- Now we have four terms, show each is 0
  simp only [add_zero, zero_add]
  -- Term 1: symplecticForm (inl x) (inl y) = 0
  rw [symplectic_inl_inl]
  -- Term 2: symplecticForm (inl x) (inr z) = dot x z = 0 (by cssIsValid)
  rw [symplectic_inl_inr, h x hx z hz]
  -- Term 3: symplecticForm (inr w) (inl y) = -dot w y
  -- We need dot w y = 0, but we have dot y w = 0 by cssIsValid
  -- Dot is symmetric by commutativity
  have hdot_symm : dot (n:=n) w y = dot (n:=n) y w := by
    simp [dot]
    congr 1
    ext i
    rw [mul_comm]
  rw [symplectic_inr_inl, hdot_symm, h y hy w hw, neg_zero]
  -- Term 4: symplecticForm (inr w) (inr z) = 0
  rw [symplectic_inr_inr]

-- Isotropy implies CSS validity (test on generators).
lemma css_valid_of_isotropic (Cz Cx : Submodule α (Vec n α))
  (hIso : IsIsotropic (n:=n) (cssStabilizer (n:=n) Cz Cx)) : cssIsValid (n:=n) Cz Cx := by
  classical
  -- We need to show: ∀ x ∈ Cz, ∀ z ∈ Cx, dot x z = 0
  intro x hx z hz
  -- Consider inl x and inr z in the CSS stabilizer
  -- Since inl x ∈ map inl Cz ≤ cssStabilizer, and similarly for inr z
  have h_inl_x : (LinearMap.inl (Vec n α) (Vec n α)) x ∈ cssStabilizer (n:=n) Cz Cx := by
    rw [cssStabilizer]
    apply Submodule.mem_sup_left
    apply Submodule.mem_map_of_mem hx
  have h_inr_z : (LinearMap.inr (Vec n α) (Vec n α)) z ∈ cssStabilizer (n:=n) Cz Cx := by
    rw [cssStabilizer]
    apply Submodule.mem_sup_right
    apply Submodule.mem_map_of_mem hz
  -- By isotropy: symplecticForm (inl x) (inr z) = 0
  have h_iso : symplecticForm (n:=n)
    ((LinearMap.inl (Vec n α) (Vec n α)) x) ((LinearMap.inr (Vec n α) (Vec n α)) z) = 0 :=
    hIso ((LinearMap.inl (Vec n α) (Vec n α)) x) h_inl_x ((LinearMap.inr (Vec n α) (Vec n α)) z) h_inr_z
  -- But symplecticForm (inl x) (inr z) = dot x z
  have h_symplectic : symplecticForm (n:=n)
    ((LinearMap.inl (Vec n α) (Vec n α)) x) ((LinearMap.inr (Vec n α) (Vec n α)) z) = dot (n:=n) x z := by
    -- inl x = (x, 0), inr z = (0, z)
    simp [symplectic_inl_inr]
  -- Therefore dot x z = 0
  rwa [← h_symplectic] at h_iso

-- Equivalence.
theorem css_isotropic_iff_valid (Cz Cx : Submodule α (Vec n α)) :
  IsIsotropic (n:=n) (cssStabilizer (n:=n) Cz Cx) ↔ cssIsValid (n:=n) Cz Cx := by
  constructor
  · exact css_valid_of_isotropic (n:=n) Cz Cx
  · exact css_isotropic_of_valid (n:=n) Cz Cx

/-! 3) Dimension/parameters of the CSS stabilizer -/

-- The two mapped subspaces intersect trivially.
lemma css_images_disjoint (Cz Cx : Submodule α (Vec n α)) :
  (Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz) ⊓
  (Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx) = ⊥ := by
  classical
  ext p; constructor
  · intro hp
    rcases hp with ⟨hpL, hpR⟩
    rcases hpL with ⟨x, hx, rfl⟩
    rcases hpR with ⟨z, hz, hzEq⟩
    -- (x,0) = (0,z) ⇒ x=0 and z=0
    have hx0 : x = (fun _ => 0) := by
      ext i; have := congrArg (fun t => t.1 i) hzEq; simpa using this
    have hz0 : z = (fun _ => 0) := by
      ext i; have := congrArg (fun t => t.2 i) hzEq; simpa using this
    simp [hx0, hz0]
  · intro hp; simp at hp; exact hp

-- Finite dimensional rank of the CSS stabilizer equals sum of ranks.
theorem finrank_cssStabilizer (Cz Cx : Submodule α (Vec n α)) [FiniteDimensional α (Vec n α)] :
  FiniteDimensional.finrank α (cssStabilizer (n:=n) Cz Cx) =
  FiniteDimensional.finrank α Cz + FiniteDimensional.finrank α Cx := by
  classical
  -- Use finrank_sup_add_finrank_inf and disjointness of the images.
  have hdisj :
    (Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz) ⊓
    (Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx) = ⊥ :=
    css_images_disjoint (n:=n) Cz Cx
  have hfinf : FiniteDimensional.finrank α ((Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz) ⊓ (Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx)) = 0 := by
    simpa [hdisj]
  have hsumeq := Submodule.finrank_sup_add_finrank_inf
    (A:=Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz)
    (B:=Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx)
  -- map preserves finrank
  -- LinearMap.inl and LinearMap.inr are injective, so finrank is preserved.
  have hAeq : FiniteDimensional.finrank α (Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz) =
    FiniteDimensional.finrank α Cz := by
    -- inl is injective, so the map is an isomorphism onto its image
    -- Use that finrank of image equals finrank of domain for injective maps
    have hinj : Function.Injective (LinearMap.inl (Vec n α) (Vec n α)) := LinearMap.inl_injective
    -- The key is that Submodule.map of an injective map preserves finrank
    -- We can use: finrank (map f M) = finrank M when f is injective
    -- This follows from the rank-nullity theorem: finrank M = finrank (map f M) + finrank (M ⊓ ker f)
    -- Since ker f = ⊥ for injective f, we get finrank M = finrank (map f M)
    have hker : LinearMap.ker (LinearMap.inl (Vec n α) (Vec n α)) = ⊥ := LinearMap.ker_inl
    -- Use Submodule.finrank_map with the injectivity
    rw [Submodule.finrank_map]
    -- Now we need to show that finrank (Cz ⊓ ker (inl)) = 0
    -- Since ker (inl) = ⊥, we have Cz ⊓ ⊥ = ⊥, so finrank is 0
    have : Cz ⊓ LinearMap.ker (LinearMap.inl (Vec n α) (Vec n α)) = ⊥ := by
      rw [hker, Submodule.inf_bot]
    simp [this]
  have hBeq : FiniteDimensional.finrank α (Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx) =
    FiniteDimensional.finrank α Cx := by
    -- Similar proof for inr
    have hinj : Function.Injective (LinearMap.inr (Vec n α) (Vec n α)) := LinearMap.inr_injective
    have hker : LinearMap.ker (LinearMap.inr (Vec n α) (Vec n α)) = ⊥ := LinearMap.ker_inr
    rw [Submodule.finrank_map]
    have : Cx ⊓ LinearMap.ker (LinearMap.inr (Vec n α) (Vec n α)) = ⊥ := by
      rw [hker, Submodule.inf_bot]
    simp [this]
  have hSupDef : (Submodule.map (LinearMap.inl (Vec n α) (Vec n α)) Cz ⊔ Submodule.map (LinearMap.inr (Vec n α) (Vec n α)) Cx)
      = cssStabilizer (n:=n) Cz Cx := rfl
  have := hsumeq
  -- finrank(A ⊔ B) + finrank(A ⊓ B) = finrank A + finrank B
  -- so finrank(A ⊔ B) = finrank A + finrank B
  simpa [hSupDef, hAeq, hBeq, hfinf]

/-! 4) Matrix presentation bridge (rows) -/

-- For matrices, we work with row spaces (each row is a length-n vector).
noncomputable def rowSpace {r : ℕ} (H : Matrix (Fin r) (Fin n) α) : Submodule α (Vec n α) :=
  Submodule.span α (((Finset.univ : Finset (Fin r)).image (fun i => fun j => H i j) : Finset (Vec n α)) : Set (Vec n α))

def matricesCommute {rX rZ : ℕ} (Hx : Matrix (Fin rX) (Fin n) α) (Hz : Matrix (Fin rZ) (Fin n) α) : Prop :=
  Hx ⬝ Matrix.transpose Hz = 0

-- Row space orthogonality from matrix commutation (parity-check style). Proof sketched.
theorem matricesCommute_cssValid {rX rZ : ℕ}
  (Hx : Matrix (Fin rX) (Fin n) α) (Hz : Matrix (Fin rZ) (Fin n) α)
  (h : matricesCommute (n:=n) Hx Hz) :
  cssIsValid (n:=n) (rowSpace (n:=n) Hz) (rowSpace (n:=n) Hx) := by
  -- Standard CSS condition: Hx * Hzᵀ = 0 ⇒ every row of Hx is orthogonal to every row of Hz.
  -- Extends by linearity to their spans.
  classical
  -- Full formalization would expand spans and use bilinearity of `dot`.
  -- Implementing completely is lengthy; we record the intended property.
  -- TODO: replace with a full linear-algebraic proof aligning `dot` with matrix product.
  sorry

/-! 5) Weights and distances -/

-- Pauli weight counts coordinates where either X or Z component is nonzero.
noncomputable def pauliWeight (p : SympVec n α) : ℕ :=
  (Finset.univ.filter (fun i => p.1 i ≠ 0 ∨ p.2 i ≠ 0)).card

-- Distances in CSS codes, defined via classical weights on appropriate sets.
noncomputable def dX (Cz Cx : Submodule α (Vec n α)) : ℕ :=
  by
    classical
    let universe : Finset (Vec n α) := Finset.univ
    let candidates := universe.filter (fun x => (∀ z ∈ Cz, dot (n:=n) z x = 0) ∧ ¬ x ∈ Cz ∧ weight (n:=n) x ≠ 0)
    exact
      if h : candidates.Nonempty then
        let ws := candidates.image (fun x => weight (n:=n) x)
        have hw : ws.Nonempty := by
          rcases h with ⟨x, hx⟩
          exact ⟨_, by simpa using Finset.mem_image.mpr ⟨x, hx, rfl⟩⟩
        Finset.min' ws hw
      else 0

noncomputable def dZ (Cz Cx : Submodule α (Vec n α)) : ℕ :=
  by
    classical
    let universe : Finset (Vec n α) := Finset.univ
    let candidates := universe.filter (fun z => (∀ x ∈ Cx, dot (n:=n) x z = 0) ∧ ¬ z ∈ Cx ∧ weight (n:=n) z ≠ 0)
    exact
      if h : candidates.Nonempty then
        let ws := candidates.image (fun z => weight (n:=n) z)
        have hw : ws.Nonempty := by
          rcases h with ⟨z, hz⟩
          exact ⟨_, by simpa using Finset.mem_image.mpr ⟨z, hz, rfl⟩⟩
        Finset.min' ws hw
      else 0

noncomputable def dCSS (Cz Cx : Submodule α (Vec n α)) : ℕ := Nat.min (dX (n:=n) Cz Cx) (dZ (n:=n) Cz Cx)

/-! 6) Binary Steane [[7,1,3]] skeleton -/

section Steane
  open scoped Matrix
  noncomputable def H_steane : Matrix (Fin 3) (Fin 7) (ZMod 2) := fun i j =>
    -- Standard 3×7 Hamming parity-check matrix (columns are nonzero 3-bit vectors)
    match (j : ℕ) with
    | 0 => ![1,0,1] i
    | 1 => ![1,1,1] i
    | 2 => ![1,1,0] i
    | 3 => ![1,0,0] i
    | 4 => ![0,1,1] i
    | 5 => ![0,1,0] i
    | _ => ![0,0,1] i

  -- Hx = Hz = H_steane; the standard CSS construction.
  theorem steane_commutes : matricesCommute (n:=7) H_steane H_steane := by
    -- Over GF(2), this specific H satisfies H * Hᵀ = 0.
    -- We prove this by showing that each entry of H_steane ⬝ H_steaneᵀ is 0.
    unfold matricesCommute
    ext i j
    simp [Matrix.mul_apply, Matrix.transpose, H_steane, Matrix.dotProduct]
    -- Compute the dot product of row i and row j of H_steane
    -- Over ZMod 2, we need to show the sum mod 2 is 0
    -- The Hamming parity-check matrix has the property that H * Hᵀ = 0
    -- This follows because each row is orthogonal to itself and all other rows
    fin_cases i <;> fin_cases j <;> decide

end Steane

end CodingTheory
