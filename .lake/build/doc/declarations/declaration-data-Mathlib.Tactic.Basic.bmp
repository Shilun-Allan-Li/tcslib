{"name":"Mathlib.Tactic.Basic","instances":[],"imports":["Init","Lean","Std","Mathlib.Tactic.PPWithUniv","Mathlib.Tactic.ExtendDoc"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L164-L175","name":"Mathlib.Tactic.clearValue","line":164,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.clearValue","doc":"`clear_value n₁ n₂ ...` clears the bodies of the local definitions `n₁, n₂ ...`, changing them\ninto regular hypotheses. A hypothesis `n : α := t` is changed to `n : α`.\n\nThe order of `n₁ n₂ ...` does not matter, and values will be cleared in reverse order of\nwhere they appear in the context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.clearValue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">clearValue</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L146-L162","name":"Lean.MVarId.clearValue","line":146,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Lean.MVarId.clearValue","doc":"Clears the value of the local definition `fvarId`. Ensures that the resulting goal state\nis still type correct. Throws an error if it is a local hypothesis without a value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Lean.MVarId.clearValue\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">clearValue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L136-L142","name":"Mathlib.Tactic.clearAuxDecl","line":136,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.clearAuxDecl","doc":"This tactic clears all auxiliary declarations from the context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.clearAuxDecl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">clearAuxDecl</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L130-L134","name":"Mathlib.Tactic.tacticMatch_target_","line":130,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticMatch_target_","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticMatch_target_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticMatch_target_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L128-L128","name":"Mathlib.Tactic.tacticAssumption'","line":128,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticAssumption'","doc":"Try calling `assumption` on all goals; succeeds if it closes at least one goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticAssumption'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticAssumption'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L122-L125","name":"Mathlib.Tactic.evalIntrov.intro1PStep","line":122,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.evalIntrov.intro1PStep","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.evalIntrov.intro1PStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalIntrov</span>.<span class=\"name\">intro1PStep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L114-L121","name":"Mathlib.Tactic.evalIntrov.introsDep","line":114,"kind":"opaque","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.evalIntrov.introsDep","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.evalIntrov.introsDep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalIntrov</span>.<span class=\"name\">introsDep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L105-L125","name":"Mathlib.Tactic.evalIntrov","line":105,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.evalIntrov","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.evalIntrov\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">evalIntrov</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L72-L104","name":"Mathlib.Tactic.introv","line":72,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.introv","doc":"The tactic `introv` allows the user to automatically introduce the variables of a theorem and\nexplicitly name the non-dependent hypotheses.\nAny dependent hypotheses are assigned their default names.\n\nExamples:\n```\nexample : ∀ a b : Nat, a = b → b = a := by\n  introv h,\n  exact h.symm\n```\nThe state after `introv h` is\n```\na b : ℕ,\nh : a = b\n⊢ b = a\n```\n\n```\nexample : ∀ a b : Nat, a = b → ∀ c, b = c → a = c := by\n  introv h₁ h₂,\n  exact h₁.trans h₂\n```\nThe state after `introv h₁ h₂` is\n```\na b : ℕ,\nh₁ : a = b,\nc : ℕ,\nh₂ : b = c\n⊢ a = c\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.introv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">introv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L62-L62","name":"Mathlib.Tactic.tacticTransitivity___","line":62,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticTransitivity___","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.tacticTransitivity___\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticTransitivity___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L55-L60","name":"Mathlib.Tactic.pushFVarAliasInfo","line":55,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.pushFVarAliasInfo","doc":"Given two arrays of `FVarId`s, one from an old local context and the other from a new local\ncontext, pushes `FVarAliasInfo`s into the info tree for corresponding pairs of `FVarId`s.\nRecall that variables linked this way should be considered to be semantically identical.\n\nThe effect of this is, for example, the unused variable linter will see that variables\nfrom the first array are used if corresponding variables in the second array are used. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.pushFVarAliasInfo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">pushFVarAliasInfo</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Elab/InfoTree/Types.html#Lean.Elab.MonadInfoTree\">Lean.Elab.MonadInfoTree</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(oldFVars : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newFVars : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(newLCtx : <a href=\"./Lean/LocalContext.html#Lean.LocalContext\">Lean.LocalContext</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L43-L47","name":"Mathlib.Tactic.«termType*»","line":43,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.«termType*»","doc":"The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable\n`> 0` for each variable in the sequence. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.«termType*»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«termType*»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L37-L41","name":"Mathlib.Tactic.«termSort*»","line":37,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.«termSort*»","doc":"The syntax `variable (X Y ... Z : Sort*)` creates a new distinct implicit universe variable\nfor each variable in the sequence. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.«termSort*»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«termSort*»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L29-L35","name":"Mathlib.Tactic.expandLemma","line":29,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.expandLemma","doc":"Implementation of the `lemma` command, by macro expansion to `theorem`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.expandLemma\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">expandLemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Macro\">Lean.Macro</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L24-L26","name":"Mathlib.Tactic.lemma","line":24,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.lemma","doc":"`lemma` means the same as `theorem`. It is used to denote \"less important\" theorems "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.lemma\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">lemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L18-L22","name":"Mathlib.Tactic.elabVariables","line":18,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.elabVariables","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.elabVariables\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabVariables</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElab\">Lean.Elab.Command.CommandElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/3b81a542da60bafaae06756ff194ad50e9c83921/Mathlib/Tactic/Basic.lean#L16-L16","name":"Mathlib.Tactic.variables","line":16,"kind":"def","docLink":"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.variables","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Basic.html#Mathlib.Tactic.variables\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">variables</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}